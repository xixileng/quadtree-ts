/* https://github.com/timohausmann/quadtree-ts.git v2.2.2 */
!function(t,s){"object"==typeof exports&&"undefined"!=typeof module?module.exports=s():"function"==typeof define&&define.amd?define(s):(t="undefined"!=typeof globalThis?globalThis:t||self).Quadtree=s()}(this,(function(){"use strict";class t{constructor(t,s=0){this.bounds={x:t.x||0,y:t.y||0,width:t.width,height:t.height},this.maxObjects="number"==typeof t.maxObjects?t.maxObjects:10,this.maxLevels="number"==typeof t.maxLevels?t.maxLevels:4,this.level=s,this.objects=[],this.nodes=[]}getIndex(t){return t.qtIndex(this.bounds)}split(){const s=this.level+1,e=this.bounds.width/2,i=this.bounds.height/2,h=this.bounds.x,n=this.bounds.y,o=[{x:h+e,y:n},{x:h,y:n},{x:h,y:n+i},{x:h+e,y:n+i}];for(let h=0;h<4;h++)this.nodes[h]=new t({x:o[h].x,y:o[h].y,width:e,height:i,maxObjects:this.maxObjects,maxLevels:this.maxLevels},s);const r=[];for(let t=0;t<this.objects.length;t++){const s=this.getIndex(this.objects[t]);1===s.length?this.nodes[s[0]].insert(this.objects[t]):r.push(this.objects[t])}this.objects=r}insert(t){if(this.nodes.length){const s=this.getIndex(t);1===s.length?this.nodes[s[0]].insert(t):this.objects.push(t)}else this.objects.length<this.maxObjects||this.level>=this.maxLevels?this.objects.push(t):(this.split(),this.insert(t))}retrieve(t){const s=this.getIndex(t);let e=this.objects;if(this.nodes.length)for(let i=0;i<s.length;i++)e=e.concat(this.nodes[s[i]].retrieve(t));return e}remove(t,s=!1){const e=this.objects.indexOf(t);e>-1&&this.objects.splice(e,1);for(let s=0;s<this.nodes.length;s++)this.nodes[s].remove(t);return 0!==this.level||s||this.join(),-1!==e}update(t,s=!1){this.remove(t,s),this.insert(t)}join(){let t=Array.from(this.objects);for(let s=0;s<this.nodes.length;s++){const e=this.nodes[s].join();t=t.concat(e)}const s=Array.from(new Set(t));if(s.length<=this.maxObjects){this.objects=s;for(let t=0;t<this.nodes.length;t++)this.nodes[t].objects=[];this.nodes=[]}return t}clear(){this.objects=[];for(let t=0;t<this.nodes.length;t++)this.nodes.length&&this.nodes[t].clear();this.nodes=[]}}class s{constructor(t){this.x=t.x,this.y=t.y,this.r=t.r,this.data=t.data}qtIndex(t){const e=[],i=t.width/2,h=t.height/2,n=t.x+i,o=t.y+h,r=[[n,t.y],[t.x,t.y],[t.x,o],[n,o]];for(let t=0;t<r.length;t++)s.intersectRect(this.x,this.y,this.r,r[t][0],r[t][1],r[t][0]+i,r[t][1]+h)&&e.push(t);return e}static intersectRect(t,s,e,i,h,n,o){const r=t-Math.max(i,Math.min(t,n)),c=s-Math.max(h,Math.min(s,o));return r*r+c*c<e*e}}class e{constructor(t){this.x1=t.x1,this.y1=t.y1,this.x2=t.x2,this.y2=t.y2,this.data=t.data}qtIndex(t){const s=[],i=t.width/2,h=t.height/2,n=t.x+i,o=t.y+h,r=[[n,t.y],[t.x,t.y],[t.x,o],[n,o]];for(let t=0;t<r.length;t++)e.intersectRect(this.x1,this.y1,this.x2,this.y2,r[t][0],r[t][1],r[t][0]+i,r[t][1]+h)&&s.push(t);return s}static intersectRect(t,s,e,i,h,n,o,r){if(t<=h&&e<=h||s<=n&&i<=n||t>=o&&e>=o||s>=r&&i>=r)return!1;if(t>=h&&t<=o&&s>=n&&s<=r||e>=h&&e<=o&&i>=n&&i<=r)return!0;const c=(i-s)/(e-t);let d=c*(h-t)+s;if(d>n&&d<r)return!0;if(d=c*(o-t)+s,d>n&&d<r)return!0;let l=(n-s)/c+t;return l>h&&l<o||(l=(r-s)/c+t,l>h&&l<o)}}return Object.assign(t,{Rectangle:class{constructor(t){this.x=t.x,this.y=t.y,this.width=t.width,this.height=t.height,this.data=t.data}qtIndex(t){const s=[],e=t.x+t.width/2,i=t.y+t.height/2,h=this.y<i,n=this.x<e,o=this.x+this.width>e,r=this.y+this.height>i;return h&&o&&s.push(0),n&&h&&s.push(1),n&&r&&s.push(2),o&&r&&s.push(3),s}},Circle:s,Line:e})}));
